import os

from merge.utils import Singleton


class Config_filter(metaclass=Singleton):
    CONFIG_DICT = dict(
        FRAGALYSIS_DATA_DIR="/home/swills/Oxford/data/Fragalysis",
        OUTPUT_DIR="/home/swills/Oxford/fragment_network/fragment_network_merges/tests/test_output",
        WORKING_DIR=os.path.join(os.getcwd(), "data"),
        N_CPUS_FILTER_PAIR=2,
        # FOR FILTERING THE MERGES POST-DATABASE QUERY
        FILTER_PIPELINE=['DescriptorFilter', 'EmbeddingFilter', 'OverlapFilter'],
        SCORING_PIPELINE=[],  # 'IfpScore'
        PIPELINE_DICT={  # used to help import the classes in filter_pipeline.py
            'DescriptorFilter': 'filter.descriptor_filter',
            'EmbeddingFilter': 'filter.embedding_filter',
            'ExpansionFilter': 'filter.expansion_filter',
            'OverlapFilter': 'filter.overlap_filter',
            'FragmensteinFilter': 'filter.fragmenstein_filter',
            'IfpScore': 'filter.ifp_score'
        },
        # PARAMETERS INVOLVED IN INDIVIDUAL FILTERS
        FRAGA_VOLUME=0.9,  # expansion_filter.py; the threshold for volume of the merge that comes from fragment A
        ENERGY_THRESHOLD=10,  # embedding_filter.py; ratio of energy of unconstrained vs constrained conformations,
        CLASH_DIST=0.15,  # overlap_filter.py; proportion of ligand overlapping with protein categorized as not fitting
        COVALENT_RESI='2B',  # fragmenstein_filter.py; select covalent residue or if none then the first residue
        COM_RMSD=1,  # fragmenstein_filter.py; threshold for combined RMSD to rule out poses generated by Fragmenstein
)

    @classmethod
    def get(cls, key):
        val = os.environ.get(key, None)
        if val:
            return val
        else:
            return cls.CONFIG_DICT[key]

    # this method will allow instances to access config properties as obj.PROPERTY; useful for subclassing
    def __getattr__(self, key):
        if key in self.__dict__:
            val = self.__dict__[key]
            return val
        else:
            return self.get(key)

    def __setattr__(self, key, value):
        if value is not None:
            super(Config_filter, self).__setattr__(key, value)
        # self.CONFIG_DICT[key] = value
        
    def __init__(self):
        pass


config_filter = Config_filter()
