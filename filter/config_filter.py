import os

from utils.singleton import Singleton


class Config_filter(metaclass=Singleton):
    CONFIG_DICT = dict(
        FRAGALYSIS_DATA_DIR="/home/swills/Oxford/data/Fragalysis",
        OUTPUT_DIR="/home/swills/Oxford/fragment_network/fragment_network_merges/tests/test_output",
        WORKING_DIR="/home/swills/Oxford/fragment_network/fragment_network_merges/tests/test_output",
        # WORKING_DIR=os.path.join(os.getcwd(), "data"),
        N_CPUS_FILTER_PAIR=os.cpu_count(),
        # FOR FILTERING THE MERGES POST-DATABASE QUERY
        FILTER_PIPELINE=["DescriptorFilter", "ExpansionFilter", "EmbeddingFilter", "OverlapFilter", "FragmensteinFilter"],
        #FILTER_PIPELINE=["EmbeddingFilterSS"],
        SCORING_PIPELINE=["IfpScore", "SuCOSScore"],  # 'IfpScore'
        PIPELINE_DICT={  # used to help import the classes in filter_pipeline.py
            "DescriptorFilter": "filter.descriptor_filter",
            "EmbeddingFilter": "filter.embedding_filter",
            "ExpansionFilter": "filter.expansion_filter",
            "OverlapFilter": "filter.overlap_filter",
            "FragmensteinFilter": "filter.fragmenstein_filter",
            "IfpScore": "filter.ifp_score",
            "PlipIfpScore": "filter.plip_ifp_score",
            "SuCOSScore": "filter.sucos_score",
            "ElaboratabilityScore": "filter.elaboratability_score",
            "EmbeddingFilterSS": "filter.embedding_filter_ss",  # for placing similarity search stuff
            "EnergyFilter": "filter.energy_filter",
            "NonringBondFilter": "filter.nonring_bond_filter"
        },
        # PARAMETERS INVOLVED IN INDIVIDUAL FILTERS
        ROTAT_THRESHOLD=10,  # descriptor_filter.py; max number rotatable bonds
        HAC_THRESHOLD=15,  # descriptor_filter.py; min number of heavy atoms
        N_MCS_ATOMS=3,  # expansion_filter.py; minimum number of atoms contributed from fragment B
        ENERGY_THRESHOLD=7.0,  # embedding_filter.py; ratio of energy of unconstrained vs constrained conformations,
        N_CONFORMATIONS=50,  # embedding_filter.py; the number of unconstrained conformations to generate
        ATOM_CLASH_DIST=1.0,  # embedding_filter.py; min atom dist in the frag A/B substructures to be clashes/removed
        CLASH_DIST=0.16,  # overlap_filter.py; proportion of ligand overlapping with protein categorized as not fitting
        COVALENT_RESI=1,  # fragmenstein_filter.py; select covalent residue or if none then the first residue
        COM_RMSD=1,  # fragmenstein_filter.py; threshold for combined RMSD to rule out poses generated by Fragmenstein
        TIMEOUT=600,  # fragmenstein_filter.py; time out for place smiles
        LINKER_PATH_THRESHOLD=8,  # nonring_bond_filter.py; max length of linkers in molecules
        SIDECHAIN_PATH_THRESHOLD=6,  # nonring_bond_filter.py; max length of sidechains
        N_ELAB_DISTS=10,  # elaboratability_score.py; number of dists to closest atoms to calculate
        MIN_ELAB_ANGLE=10,  # elaboratability_score.py; angle between dist vectors
        PLIP_SCORE_THRESHOLD=0.5,  # plip_ifp_score.py; proportion of bonds maintained
    )

    @classmethod
    def get(cls, key):
        val = os.environ.get(key, None)
        if val:
            return val
        else:
            return cls.CONFIG_DICT[key]

    # this method will allow instances to access config properties as obj.PROPERTY; useful for subclassing
    def __getattr__(self, key):
        if key in self.__dict__:
            val = self.__dict__[key]
            return val
        else:
            return self.get(key)

    def __setattr__(self, key, value):
        if value is not None:
            super(Config_filter, self).__setattr__(key, value)
        # self.CONFIG_DICT[key] = value

    def __init__(self):
        pass


config_filter = Config_filter()
